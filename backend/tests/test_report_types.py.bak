"""
Comprehensive tests for report_types.py module.
This ensures full coverage for the report data types system.
"""

import pytest
import json
import sys
from datetime import datetime
from typing import Dict, Any, List

# Add the src directory to Python path and import directly
from pathlib import Path
backend_dir = Path(__file__).parent.parent
src_dir = backend_dir / "src"
sys.path.insert(0, str(src_dir))

# Import the module directly using importlib
import importlib.util
spec = importlib.util.spec_from_file_location("report_types", src_dir / "types" / "report_types.py")
report_types_module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(report_types_module)

# Now import from the loaded module
from report_types_module import (
    ConversionStatus,
    ImpactLevel,
    ReportMetadata,
    SummaryReport,
    FeatureAnalysisItem,
    FeatureAnalysis,
    AssumptionReportItem,
    AssumptionsReport,
    DeveloperLog,
    InteractiveReport,
    ModConversionStatus,
    SmartAssumption,
    FeatureConversionDetail,
    AssumptionDetail,
    LogEntry,
    create_report_metadata,
    calculate_quality_score
)


class TestConversionStatus:
    """Test ConversionStatus constants."""
    
    def test_status_constants(self):
        """Test that status constants are correctly defined."""
        assert ConversionStatus.SUCCESS == "success"
        assert ConversionStatus.PARTIAL == "partial"
        assert ConversionStatus.FAILED == "failed"
        assert ConversionStatus.PROCESSING == "processing"


class TestImpactLevel:
    """Test ImpactLevel constants."""
    
    def test_impact_constants(self):
        """Test that impact level constants are correctly defined."""
        assert ImpactLevel.LOW == "low"
        assert ImpactLevel.MEDIUM == "medium"
        assert ImpactLevel.HIGH == "high"
        assert ImpactLevel.CRITICAL == "critical"


class TestReportMetadata:
    """Test ReportMetadata dataclass."""
    
    def test_metadata_creation(self):
        """Test creating ReportMetadata with all required fields."""
        metadata = ReportMetadata(
            report_id="test_report_123",
            job_id="job_456",
            generation_timestamp=datetime(2023, 1, 1, 12, 0, 0)
        )
        
        assert metadata.report_id == "test_report_123"
        assert metadata.job_id == "job_456"
        assert metadata.version == "2.0.0"  # default value
        assert metadata.report_type == "comprehensive"  # default value
        assert metadata.generation_timestamp == datetime(2023, 1, 1, 12, 0, 0)
    
    def test_metadata_with_custom_values(self):
        """Test creating ReportMetadata with custom values."""
        metadata = ReportMetadata(
            report_id="custom_report",
            job_id="custom_job",
            generation_timestamp=datetime.now(),
            version="1.0.0",
            report_type="summary"
        )
        
        assert metadata.version == "1.0.0"
        assert metadata.report_type == "summary"


class TestSummaryReport:
    """Test SummaryReport dataclass."""
    
    def test_summary_report_creation_minimal(self):
        """Test creating SummaryReport with minimal required fields."""
        summary = SummaryReport(
            overall_success_rate=85.5,
            total_features=100,
            converted_features=80,
            partially_converted_features=15,
            failed_features=5,
            assumptions_applied_count=10,
            processing_time_seconds=120.5
        )
        
        assert summary.overall_success_rate == 85.5
        assert summary.total_features == 100
        assert summary.converted_features == 80
        assert summary.partially_converted_features == 15
        assert summary.failed_features == 5
        assert summary.assumptions_applied_count == 10
        assert summary.processing_time_seconds == 120.5
        assert summary.download_url is None
        assert summary.quick_statistics == {}  # default initialized
        assert summary.total_files_processed == 0  # default value
        assert summary.output_size_mb == 0.0  # default value
        assert summary.conversion_quality_score == 0.0  # default value
        assert summary.recommended_actions == []  # default initialized
    
    def test_summary_report_with_all_fields(self):
        """Test creating SummaryReport with all fields populated."""
        summary = SummaryReport(
            overall_success_rate=90.0,
            total_features=50,
            converted_features=45,
            partially_converted_features=3,
            failed_features=2,
            assumptions_applied_count=5,
            processing_time_seconds=60.0,
            download_url="http://example.com/report.pdf",
            quick_statistics={"conversion_rate": "90%", "errors": 2},
            total_files_processed=25,
            output_size_mb=5.5,
            conversion_quality_score=88.0,
            recommended_actions=["Review failed features", "Optimize performance"]
        )
        
        assert summary.download_url == "http://example.com/report.pdf"
        assert summary.quick_statistics == {"conversion_rate": "90%", "errors": 2}
        assert summary.total_files_processed == 25
        assert summary.output_size_mb == 5.5
        assert summary.conversion_quality_score == 88.0
        assert summary.recommended_actions == ["Review failed features", "Optimize performance"]


class TestFeatureAnalysisItem:
    """Test FeatureAnalysisItem dataclass."""
    
    def test_feature_analysis_item_creation(self):
        """Test creating FeatureAnalysisItem with required fields."""
        feature = FeatureAnalysisItem(
            name="test_feature",
            original_type="Java: Block",
            converted_type="Bedrock: jigsaw",
            status="success",
            compatibility_score=85.5,
            assumptions_used=["Assumption 1", "Assumption 2"],
            impact_assessment="Medium impact"
        )
        
        assert feature.name == "test_feature"
        assert feature.original_type == "Java: Block"
        assert feature.converted_type == "Bedrock: jigsaw"
        assert feature.status == "success"
        assert feature.compatibility_score == 85.5
        assert feature.assumptions_used == ["Assumption 1", "Assumption 2"]
        assert feature.impact_assessment == "Medium impact"
        assert feature.visual_comparison is None
        assert feature.technical_notes is None
    
    def test_feature_analysis_item_with_optional_fields(self):
        """Test FeatureAnalysisItem with optional fields."""
        visual = {"before": "java_block.png", "after": "bedrock_jigsaw.png"}
        feature = FeatureAnalysisItem(
            name="complex_feature",
            original_type="Java: Entity",
            converted_type="Bedrock: entity",
            status="partial",
            compatibility_score=70.0,
            assumptions_used=["Animation assumption"],
            impact_assessment="Low impact",
            visual_comparison=visual,
            technical_notes="Animation conversion requires manual adjustment"
        )
        
        assert feature.visual_comparison == visual
        assert feature.technical_notes == "Animation conversion requires manual adjustment"
    
    def test_feature_analysis_item_to_dict(self):
        """Test converting FeatureAnalysisItem to dictionary."""
        feature = FeatureAnalysisItem(
            name="test_feature",
            original_type="Java: Block",
            converted_type="Bedrock: jigsaw",
            status="success",
            compatibility_score=85.5,
            assumptions_used=["Assumption 1"],
            impact_assessment="Low impact"
        )
        
        expected = {
            "name": "test_feature",
            "original_type": "Java: Block",
            "converted_type": "Bedrock: jigsaw",
            "status": "success",
            "compatibility_score": 85.5,
            "assumptions_used": ["Assumption 1"],
            "impact_assessment": "Low impact",
            "visual_comparison": None,
            "technical_notes": None
        }
        
        assert feature.to_dict() == expected


class TestFeatureAnalysis:
    """Test FeatureAnalysis dataclass."""
    
    def test_feature_analysis_creation_minimal(self):
        """Test creating FeatureAnalysis with minimal fields."""
        features = [
            FeatureAnalysisItem(
                name="feature1",
                original_type="Java: Block",
                converted_type="Bedrock: jigsaw",
                status="success",
                compatibility_score=85.5,
                assumptions_used=["Assumption 1"],
                impact_assessment="Low impact"
            )
        ]
        
        analysis = FeatureAnalysis(
            features=features,
            compatibility_mapping_summary="Good compatibility",
            impact_assessment_summary="Overall low impact"
        )
        
        assert len(analysis.features) == 1
        assert analysis.compatibility_mapping_summary == "Good compatibility"
        assert analysis.impact_assessment_summary == "Overall low impact"
        assert analysis.visual_comparisons_overview is None
        assert analysis.total_compatibility_score == 0.0  # default value
        assert analysis.feature_categories == {}  # default initialized
        assert analysis.conversion_patterns == []  # default initialized
    
    def test_feature_analysis_with_all_fields(self):
        """Test FeatureAnalysis with all fields populated."""
        features = [FeatureAnalysisItem(
            name="feature1",
            original_type="Java: Block",
            converted_type="Bedrock: jigsaw",
            status="success",
            compatibility_score=85.5,
            assumptions_used=["Assumption 1"],
            impact_assessment="Low impact"
        )]
        
        analysis = FeatureAnalysis(
            features=features,
            compatibility_mapping_summary="Good compatibility",
            visual_comparisons_overview="Visual comparisons available",
            impact_assessment_summary="Overall low impact",
            total_compatibility_score=85.5,
            feature_categories={"blocks": ["feature1"]},
            conversion_patterns=["Pattern 1", "Pattern 2"]
        )
        
        assert analysis.visual_comparisons_overview == "Visual comparisons available"
        assert analysis.total_compatibility_score == 85.5
        assert analysis.feature_categories == {"blocks": ["feature1"]}
        assert analysis.conversion_patterns == ["Pattern 1", "Pattern 2"]


class TestAssumptionReportItem:
    """Test AssumptionReportItem dataclass."""
    
    def test_assumption_report_item_creation_minimal(self):
        """Test creating AssumptionReportItem with minimal fields."""
        assumption = AssumptionReportItem(
            original_feature="Java: Redstone behavior",
            assumption_type="Logic conversion",
            bedrock_equivalent="Bedrock: Redstone dust",
            impact_level="medium",
            user_explanation="Redstone logic converted successfully",
            technical_details="Standard redstone conversion pattern"
        )
        
        assert assumption.original_feature == "Java: Redstone behavior"
        assert assumption.assumption_type == "Logic conversion"
        assert assumption.bedrock_equivalent == "Bedrock: Redstone dust"
        assert assumption.impact_level == "medium"
        assert assumption.user_explanation == "Redstone logic converted successfully"
        assert assumption.technical_details == "Standard redstone conversion pattern"
        assert assumption.visual_example is None
        assert assumption.confidence_score == 0.0  # default value
        assert assumption.alternatives_considered == []  # default initialized
    
    def test_assumption_report_item_with_all_fields(self):
        """Test AssumptionReportItem with all fields populated."""
        visual = {"java": "redstone_java.png", "bedrock": "redstone_bedrock.png"}
        assumption = AssumptionReportItem(
            original_feature="Java: Complex Redstone",
            assumption_type="Advanced logic",
            bedrock_equivalent="Bedrock: Redstone system",
            impact_level="high",
            user_explanation="Complex redstone requires manual review",
            technical_details="Advanced redstone conversion with special handling",
            visual_example=visual,
            confidence_score=75.5,
            alternatives_considered=["Alternative 1", "Alternative 2"]
        )
        
        assert assumption.visual_example == visual
        assert assumption.confidence_score == 75.5
        assert assumption.alternatives_considered == ["Alternative 1", "Alternative 2"]
    
    def test_assumption_report_item_to_dict(self):
        """Test converting AssumptionReportItem to dictionary."""
        assumption = AssumptionReportItem(
            original_feature="Java: Simple block",
            assumption_type="Basic conversion",
            bedrock_equivalent="Bedrock: Block",
            impact_level="low",
            user_explanation="Simple conversion",
            technical_details="Standard conversion"
        )
        
        result = assumption.to_dict()
        expected_keys = {
            "original_feature", "assumption_type", "bedrock_equivalent",
            "impact_level", "user_explanation", "technical_details",
            "visual_example", "confidence_score", "alternatives_considered"
        }
        
        assert set(result.keys()) == expected_keys
        assert result["original_feature"] == "Java: Simple block"
        assert result["confidence_score"] == 0.0
        assert result["alternatives_considered"] == []


class TestAssumptionsReport:
    """Test AssumptionsReport dataclass."""
    
    def test_assumptions_report_creation(self):
        """Test creating AssumptionsReport."""
        assumptions = [
            AssumptionReportItem(
                original_feature="Feature 1",
                assumption_type="Type 1",
                bedrock_equivalent="Equivalent 1",
                impact_level="low",
                user_explanation="Explanation 1",
                technical_details="Details 1"
            ),
            AssumptionReportItem(
                original_feature="Feature 2",
                assumption_type="Type 2",
                bedrock_equivalent="Equivalent 2",
                impact_level="medium",
                user_explanation="Explanation 2",
                technical_details="Details 2"
            )
        ]
        
        report = AssumptionsReport(assumptions=assumptions)
        
        assert len(report.assumptions) == 2
        assert report.total_assumptions_count == 2  # automatically calculated
        assert report.impact_distribution == {"low": 0, "medium": 0, "high": 0}  # default initialized
        assert report.category_breakdown == {}  # default initialized
    
    def test_assumptions_report_empty(self):
        """Test creating AssumptionsReport with no assumptions."""
        report = AssumptionsReport(assumptions=[])
        
        assert report.assumptions == []
        assert report.total_assumptions_count == 0
        assert report.impact_distribution == {"low": 0, "medium": 0, "high": 0}
        assert report.category_breakdown == {}


class TestDeveloperLog:
    """Test DeveloperLog dataclass."""
    
    def test_developer_log_creation_minimal(self):
        """Test creating DeveloperLog with minimal fields."""
        log = DeveloperLog(
            code_translation_details=[{"file": "test.java", "line": 10}],
            api_mapping_issues=[{"issue": "API mismatch"}],
            file_processing_log=[{"file": "test.java", "status": "processed"}],
            performance_metrics={"processing_time": 120.5},
            error_details=[]
        )
        
        assert len(log.code_translation_details) == 1
        assert len(log.api_mapping_issues) == 1
        assert len(log.file_processing_log) == 1
        assert log.performance_metrics == {"processing_time": 120.5}
        assert log.error_details == []
        assert log.optimization_opportunities == []  # default initialized
        assert log.technical_debt_notes == []  # default initialized
        assert log.benchmark_comparisons == {}  # default initialized
    
    def test_developer_log_with_all_fields(self):
        """Test DeveloperLog with all fields populated."""
        log = DeveloperLog(
            code_translation_details=[{"file": "test.java", "line": 10}],
            api_mapping_issues=[{"issue": "API mismatch"}],
            file_processing_log=[{"file": "test.java", "status": "processed"}],
            performance_metrics={"processing_time": 120.5},
            error_details=[{"error": "test error"}],
            optimization_opportunities=["Optimize loops"],
            technical_debt_notes=["Refactor legacy code"],
            benchmark_comparisons={"java_time": 100, "bedrock_time": 85}
        )
        
        assert log.optimization_opportunities == ["Optimize loops"]
        assert log.technical_debt_notes == ["Refactor legacy code"]
        assert log.benchmark_comparisons == {"java_time": 100, "bedrock_time": 85}


class TestInteractiveReport:
    """Test InteractiveReport dataclass."""
    
    def test_interactive_report_creation(self):
        """Test creating InteractiveReport with minimal fields."""
        metadata = ReportMetadata(
            report_id="test_report",
            job_id="test_job",
            generation_timestamp=datetime.now()
        )
        
        summary = SummaryReport(
            overall_success_rate=85.0,
            total_features=100,
            converted_features=85,
            partially_converted_features=10,
            failed_features=5,
            assumptions_applied_count=5,
            processing_time_seconds=120.0
        )
        
        feature_analysis = FeatureAnalysis(
            features=[],
            compatibility_mapping_summary="Test summary"
        )
        
        assumptions_report = AssumptionsReport(assumptions=[])
        
        developer_log = DeveloperLog(
            code_translation_details=[],
            api_mapping_issues=[],
            file_processing_log=[],
            performance_metrics={},
            error_details=[]
        )
        
        report = InteractiveReport(
            metadata=metadata,
            summary=summary,
            feature_analysis=feature_analysis,
            assumptions_report=assumptions_report,
            developer_log=developer_log
        )
        
        # Test default values
        assert report.navigation_structure["sections"] == ["summary", "features", "assumptions", "developer"]
        assert report.navigation_structure["expandable"] is True
        assert report.navigation_structure["search_enabled"] is True
        assert report.export_formats == ["pdf", "json", "html"]
        assert report.user_actions == ["download", "share", "feedback", "expand_all"]
    
    def test_interactive_report_to_dict(self):
        """Test converting InteractiveReport to dictionary."""
        metadata = ReportMetadata(
            report_id="test_report",
            job_id="test_job",
            generation_timestamp=datetime(2023, 1, 1, 12, 0, 0)
        )
        
        summary = SummaryReport(
            overall_success_rate=85.0,
            total_features=10,
            converted_features=8,
            partially_converted_features=1,
            failed_features=1,
            assumptions_applied_count=2,
            processing_time_seconds=60.0
        )
        
        feature_analysis = FeatureAnalysis(
            features=[],
            compatibility_mapping_summary="Test summary"
        )
        
        assumptions_report = AssumptionsReport(assumptions=[])
        
        developer_log = DeveloperLog(
            code_translation_details=[],
            api_mapping_issues=[],
            file_processing_log=[],
            performance_metrics={},
            error_details=[]
        )
        
        report = InteractiveReport(
            metadata=metadata,
            summary=summary,
            feature_analysis=feature_analysis,
            assumptions_report=assumptions_report,
            developer_log=developer_log
        )
        
        result = report.to_dict()
        
        # Check top-level keys
        expected_keys = {
            "metadata", "summary", "feature_analysis", 
            "assumptions_report", "developer_log",
            "navigation_structure", "export_formats", "user_actions"
        }
        assert set(result.keys()) == expected_keys
        
        # Check metadata serialization
        assert result["metadata"]["report_id"] == "test_report"
        assert result["metadata"]["generation_timestamp"] == "2023-01-01T12:00:00"
        
        # Check summary serialization
        assert result["summary"]["overall_success_rate"] == 85.0
        assert result["summary"]["total_features"] == 10
        
        # Check navigation structure
        assert result["navigation_structure"]["sections"] == ["summary", "features", "assumptions", "developer"]
        assert result["export_formats"] == ["pdf", "json", "html"]
    
    def test_interactive_report_to_json(self):
        """Test converting InteractiveReport to JSON string."""
        metadata = ReportMetadata(
            report_id="test_report",
            job_id="test_job",
            generation_timestamp=datetime.now()
        )
        
        summary = SummaryReport(
            overall_success_rate=100.0,
            total_features=1,
            converted_features=1,
            partially_converted_features=0,
            failed_features=0,
            assumptions_applied_count=0,
            processing_time_seconds=30.0
        )
        
        feature_analysis = FeatureAnalysis(
            features=[],
            compatibility_mapping_summary="Perfect conversion"
        )
        
        assumptions_report = AssumptionsReport(assumptions=[])
        
        developer_log = DeveloperLog(
            code_translation_details=[],
            api_mapping_issues=[],
            file_processing_log=[],
            performance_metrics={},
            error_details=[]
        )
        
        report = InteractiveReport(
            metadata=metadata,
            summary=summary,
            feature_analysis=feature_analysis,
            assumptions_report=assumptions_report,
            developer_log=developer_log
        )
        
        json_str = report.to_json()
        parsed = json.loads(json_str)
        
        assert parsed["metadata"]["report_id"] == "test_report"
        assert parsed["summary"]["overall_success_rate"] == 100.0


class TestUtilityFunctions:
    """Test utility functions."""
    
    def test_create_report_metadata_default_id(self):
        """Test create_report_metadata with default report_id."""
        metadata = create_report_metadata("test_job")
        
        assert metadata.job_id == "test_job"
        assert metadata.report_id.startswith("report_test_job_")
        assert metadata.version == "2.0.0"
        assert metadata.report_type == "comprehensive"
        assert isinstance(metadata.generation_timestamp, datetime)
    
    def test_create_report_metadata_custom_id(self):
        """Test create_report_metadata with custom report_id."""
        metadata = create_report_metadata("test_job", "custom_report_id")
        
        assert metadata.job_id == "test_job"
        assert metadata.report_id == "custom_report_id"
    
    def test_calculate_quality_score_perfect(self):
        """Test calculate_quality_score for perfect conversion."""
        summary = SummaryReport(
            overall_success_rate=100.0,
            total_features=10,
            converted_features=10,
            partially_converted_features=0,
            failed_features=0,
            assumptions_applied_count=0,
            processing_time_seconds=30.0
        )
        
        score = calculate_quality_score(summary)
        assert score == 100.0
    
    def test_calculate_quality_score_partial(self):
        """Test calculate_quality_score for partial conversion."""
        summary = SummaryReport(
            overall_success_rate=70.0,
            total_features=10,
            converted_features=5,
            partially_converted_features=3,
            failed_features=2,
            assumptions_applied_count=2,
            processing_time_seconds=45.0
        )
        
        # Calculation: (5 * 1.0 + 3 * 0.6 + 2 * 0.0) / 10 * 100
        # = (5.0 + 1.8 + 0.0) / 10 * 100 = 0.68 * 100 = 68.0
        score = calculate_quality_score(summary)
        assert score == 68.0
    
    def test_calculate_quality_score_all_failed(self):
        """Test calculate_quality_score for all failed conversion."""
        summary = SummaryReport(
            overall_success_rate=0.0,
            total_features=10,
            converted_features=0,
            partially_converted_features=0,
            failed_features=10,
            assumptions_applied_count=5,
            processing_time_seconds=60.0
        )
        
        score = calculate_quality_score(summary)
        assert score == 0.0
    
    def test_calculate_quality_score_zero_features(self):
        """Test calculate_quality_score with zero total features."""
        summary = SummaryReport(
            overall_success_rate=0.0,
            total_features=0,
            converted_features=0,
            partially_converted_features=0,
            failed_features=0,
            assumptions_applied_count=0,
            processing_time_seconds=0.0
        )
        
        score = calculate_quality_score(summary)
        assert score == 0.0


class TestLegacyTypes:
    """Test legacy compatibility types."""
    
    def test_mod_conversion_status_type(self):
        """Test ModConversionStatus TypedDict."""
        status: ModConversionStatus = {
            "name": "test_mod",
            "version": "1.0.0",
            "status": "success",
            "warnings": ["Warning 1"],
            "errors": ["Error 1"]
        }
        
        assert status["name"] == "test_mod"
        assert status["warnings"] == ["Warning 1"]
        assert status["errors"] == ["Error 1"]
    
    def test_mod_conversion_status_optional_fields(self):
        """Test ModConversionStatus with optional fields."""
        status: ModConversionStatus = {
            "name": "simple_mod",
            "version": "1.0.0",
            "status": "success"
        }
        
        # TypedDict optional fields are not present when not provided
        assert "warnings" not in status
        assert "errors" not in status
    
    def test_smart_assumption_type(self):
        """Test SmartAssumption TypedDict."""
        assumption: SmartAssumption = {
            "originalFeature": "Java: Redstone",
            "assumptionApplied": "Bedrock: Redstone dust",
            "impact": "low",
            "description": "Standard redstone conversion",
            "userExplanation": "Direct mapping available",
            "visualExamples": ["before.png", "after.png"]
        }
        
        assert assumption["originalFeature"] == "Java: Redstone"
        assert assumption["visualExamples"] == ["before.png", "after.png"]
    
    def test_feature_conversion_detail_type(self):
        """Test FeatureConversionDetail TypedDict."""
        detail: FeatureConversionDetail = {
            "feature_name": "Block conversion",
            "status": "success",
            "compatibility_notes": "Perfect match",
            "visual_comparison_before": "before.png",
            "visual_comparison_after": "after.png",
            "impact_of_assumption": "Minimal impact"
        }
        
        assert detail["feature_name"] == "Block conversion"
        assert detail["status"] == "success"
        assert detail["compatibility_notes"] == "Perfect match"
    
    def test_assumption_detail_type(self):
        """Test AssumptionDetail TypedDict."""
        detail: AssumptionDetail = {
            "assumption_id": "assumption_123",
            "feature_affected": "Redstone logic",
            "description": "Logic conversion assumption",
            "reasoning": "Standard conversion pattern",
            "impact_level": "medium",
            "user_explanation": "Manual review recommended",
            "technical_notes": "Special handling required"
        }
        
        assert detail["assumption_id"] == "assumption_123"
        assert detail["impact_level"] == "medium"
        assert detail["technical_notes"] == "Special handling required"
    
    def test_log_entry_type(self):
        """Test LogEntry TypedDict."""
        log: LogEntry = {
            "timestamp": "2023-01-01T12:00:00",
            "level": "INFO",
            "message": "Processing completed",
            "details": {"file": "test.java", "status": "success"}
        }
        
        assert log["timestamp"] == "2023-01-01T12:00:00"
        assert log["level"] == "INFO"
        assert log["message"] == "Processing completed"
        assert log["details"] == {"file": "test.java", "status": "success"}
